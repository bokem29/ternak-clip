import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import admin from 'firebase-admin';

dotenv.config();

// Initialize Firebase Admin SDK
// For local development, we'll use the project ID from env or default
try {
  if (!admin.apps.length) {
    admin.initializeApp({
      projectId: process.env.FIREBASE_PROJECT_ID || 'ternak-klip',
      // For local dev, we can use application default credentials or service account
      // If you have a service account key, uncomment and use it:
      // credential: admin.credential.cert(require('./serviceAccountKey.json'))
    });
  }
} catch (error) {
  console.warn('Firebase Admin initialization warning:', error.message);
  console.warn('Continuing without Firebase Admin - some features may not work');
}

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// In-memory data stores (in production, use a database)
// In-memory data store (for demo purposes)
const users = [
  // Test Admin for verification
  {
    id: 'user_admin_test',
    email: 'admin_test@test.com',
    password: 'password123',
    name: 'Test Admin',
    role: 'admin',
    balance: 0,
    pendingBalance: 0,
    status: 'active',
    createdAt: new Date().toISOString()
  },
  // Test Clipper for verification
  {
    id: 'user_clipper_test',
    email: 'clipper_test@test.com',
    password: 'password123',
    name: 'Test Clipper',
    role: 'clipper',
    balance: 1000000, // Rp 1.000.000 balance for testing withdraw
    pendingBalance: 0,
    status: 'active',
    createdAt: new Date().toISOString()
  }
];

const campaigns = [];
const submissions = [];
const submissionProofs = []; // Proof uploads for non-YouTube submissions
const transactions = []; // Transaction ledger (all financial transactions)
const withdrawRequests = []; // Withdrawal requests
const paymentMethods = []; // User payment methods
const auditLogs = [];
const influencerProfiles = []; // Influencer onboarding applications

// --- SEED DATA FUNCTION ---
const seedData = () => {
  // Clear existing data to ensure a fresh state for seeding
  users.length = 0;
  campaigns.length = 0;
  submissions.length = 0;
  transactions.length = 0;
  withdrawRequests.length = 0;
  paymentMethods.length = 0;
  influencerProfiles.length = 0;

  console.log('Seeding dummy data...');
  const now = new Date();
  const day = 24 * 60 * 60 * 1000;
  const hour = 60 * 60 * 1000;

  // 1. Users
  users.push(
    {
      id: 'admin_1',
      firebaseUid: 'firebase_admin_uid',
      email: 'admin@clipflow.com',
      name: 'Super Admin',
      password: 'password123',
      role: 'admin',
      balance: 0,
      pendingBalance: 0,
      status: 'active',
      verified: true,
      createdAt: new Date(now.getTime() - 60 * day).toISOString()
    },
    {
      id: 'inf_1',
      firebaseUid: 'firebase_inf_uid',
      email: 'influencer@clipflow.com',
      name: 'Gamer Pro',
      password: 'password123',
      role: 'influencer',
      balance: 0,
      pendingBalance: 0,
      budget: 25000000, // Rp 25.000.000
      status: 'verified',
      verified: true,
      influencerStatus: 'VERIFIED',
      createdAt: new Date(now.getTime() - 30 * day).toISOString()
    },
    {
      id: 'inf_2',
      email: 'beauty_vlog@test.com',
      name: 'Beauty Grace',
      password: 'password123',
      role: 'influencer',
      balance: 0,
      pendingBalance: 0,
      budget: 5000000,
      status: 'verified',
      verified: true,
      influencerStatus: 'VERIFIED',
      createdAt: new Date(now.getTime() - 15 * day).toISOString()
    },
    {
      id: 'clip_1',
      firebaseUid: 'firebase_clip_uid',
      email: 'clipper@test.com',
      name: 'Elite Clipper',
      password: 'password123',
      role: 'clipper',
      balance: 2450000, // Rp 2.450.000
      pendingBalance: 1250000,
      budget: 0,
      status: 'active',
      verified: true,
      createdAt: new Date(now.getTime() - 45 * day).toISOString()
    },
    {
      id: 'clip_2',
      email: 'newbie@test.com',
      name: 'Newbie Clipper',
      password: 'password123',
      role: 'clipper',
      balance: 75000,
      pendingBalance: 25000,
      budget: 0,
      status: 'active',
      verified: false,
      createdAt: new Date(now.getTime() - 5 * day).toISOString()
    },
    {
      id: 'clip_3',
      email: 'bad_actor@test.com',
      name: 'Suspended User',
      password: 'password123',
      role: 'clipper',
      balance: 500000,
      pendingBalance: 0,
      budget: 0,
      status: 'suspended',
      verified: false,
      createdAt: new Date(now.getTime() - 20 * day).toISOString()
    }
  );

  // 2. Campaigns
  campaigns.push(
    {
      id: 'camp_1',
      title: 'MLBB Savage Compilation - Dec 2025',
      influencerName: 'Gamer Pro',
      description: 'Cari klip savage terkeren dari stream saya minggu ini. Harus ada watermark GamerPro!',
      thumbnail: 'https://images.unsplash.com/photo-1542751371-adc38448a05e?auto=format&fit=crop&q=80&w=1000',
      allowedPlatforms: ['tiktok', 'instagram', 'youtube'],
      ratePer1kViews: 12500,
      minEligibleViews: 1000,
      maxPayableViewsPerClip: 100000,
      totalBudget: 10000000,
      remainingBudget: 8500000,
      paidBudget: 1500000,
      reservedBudget: 0,
      startDate: new Date(now.getTime() - 20 * day).toISOString(),
      endDate: new Date(now.getTime() + 10 * day).toISOString(),
      status: 'ACTIVE',
      isPublic: true,
      allowUnlimitedClippers: true,
      clippers: 45,
      submissions: 120,
      totalViews: 850000,
      createdBy: 'inf_1',
      createdAt: new Date(now.getTime() - 21 * day).toISOString()
    },
    {
      id: 'camp_2',
      title: 'Skincare Routine Highlights',
      influencerName: 'Beauty Grace',
      description: 'Potong bagian terbaik dari video skincare routine saya jadi TikTok pendek.',
      thumbnail: 'https://images.unsplash.com/photo-1596462502278-27bfdc4033c8?auto=format&fit=crop&q=80&w=1000',
      allowedPlatforms: ['tiktok'],
      ratePer1kViews: 20000,
      minEligibleViews: 2000,
      totalBudget: 5000000,
      remainingBudget: 5000000,
      paidBudget: 0,
      reservedBudget: 0,
      startDate: new Date(now.getTime() - 5 * day).toISOString(),
      endDate: new Date(now.getTime() + 25 * day).toISOString(),
      status: 'ACTIVE',
      isPublic: true,
      allowUnlimitedClippers: false,
      maxClippers: 10,
      clippers: 3,
      submissions: 5,
      totalViews: 12000,
      createdBy: 'inf_2',
      createdAt: new Date(now.getTime() - 6 * day).toISOString()
    },
    {
      id: 'camp_3',
      title: 'Funny Fail Moments - Exclusive',
      influencerName: 'Gamer Pro',
      description: 'Private campaign for selected clippers. Don\'t share outside!',
      thumbnail: 'https://images.unsplash.com/photo-1511512578047-dfb367046420?auto=format&fit=crop&q=80&w=1000',
      allowedPlatforms: ['tiktok', 'youtube'],
      ratePer1kViews: 15000,
      minEligibleViews: 500,
      totalBudget: 2000000,
      remainingBudget: 1500000,
      paidBudget: 500000,
      status: 'ACTIVE',
      isPublic: false,
      participants: ['clip_1', 'clip_2'],
      createdBy: 'inf_1',
      createdAt: new Date(now.getTime() - 10 * day).toISOString()
    }
  );

  // 3. Submissions
  submissions.push(
    {
      id: 'sub_1',
      userId: 'clip_1',
      campaignId: 'camp_1',
      title: 'Lancelot Fast Hand Skin Collector',
      platform: 'TIKTOK',
      contentUrl: 'https://tiktok.com/@elite_clippers/video/1',
      status: 'approved',
      views: 75000,
      reward: 937500, // 75 * 12500
      submittedAt: new Date(now.getTime() - 15 * day).toISOString(),
      reviewedAt: new Date(now.getTime() - 14 * day).toISOString(),
      reviewedBy: 'admin_1'
    },
    {
      id: 'sub_2',
      userId: 'clip_1',
      campaignId: 'camp_1',
      title: 'Fanny Rope 100% Precision',
      platform: 'TIKTOK',
      contentUrl: 'https://tiktok.com/@elite_clippers/video/2',
      status: 'pending',
      views: 12000,
      submittedAt: new Date(now.getTime() - 1 * day).toISOString()
    },
    {
      id: 'sub_3',
      userId: 'clip_2',
      campaignId: 'camp_1',
      title: 'Funny Gusion Blink',
      platform: 'INSTAGRAM',
      contentUrl: 'https://instagram.com/reel/1',
      status: 'rejected',
      rejectionReason: 'Video aspect ratio must be 9:16',
      views: 500,
      submittedAt: new Date(now.getTime() - 4 * day).toISOString(),
      reviewedAt: new Date(now.getTime() - 3 * day).toISOString(),
      reviewedBy: 'admin_1'
    }
  );

  // 4. Payment Methods
  paymentMethods.push(
    {
      id: 'pm_1',
      userId: 'clip_1',
      type: 'BANK',
      label: 'Main Bank (BCA)',
      bankName: 'BCA',
      accountNumber: '8830112233',
      accountName: 'Elite Clipper Store',
      isDefault: true,
      createdAt: new Date(now.getTime() - 40 * day).toISOString()
    },
    {
      id: 'pm_2',
      userId: 'clip_1',
      type: 'EWALLET',
      label: 'GOPAY',
      ewalletType: 'GOPAY',
      ewalletNumber: '08123456789',
      ewalletName: 'Elite Clipper Store',
      isDefault: false,
      createdAt: new Date(now.getTime() - 30 * day).toISOString()
    }
  );

  // 5. Withdraw Requests
  withdrawRequests.push(
    {
      id: 'withdraw_1',
      userId: 'clip_1',
      amount: 1000000,
      paymentMethodId: 'pm_1',
      paymentMethod: paymentMethods[0],
      status: 'PENDING',
      createdAt: new Date(now.getTime() - 12 * hour).toISOString()
    },
    {
      id: 'withdraw_2',
      userId: 'clip_1',
      amount: 500000,
      paymentMethodId: 'pm_1',
      status: 'APPROVED',
      createdAt: new Date(now.getTime() - 5 * day).toISOString(),
      reviewedAt: new Date(now.getTime() - 4 * day).toISOString(),
      reviewedBy: 'admin_1'
    },
    {
      id: 'withdraw_3',
      userId: 'clip_3',
      amount: 250000,
      paymentMethodId: 'pm_1',
      status: 'REJECTED',
      rejectionReason: 'Account suspended for policy violation',
      createdAt: new Date(now.getTime() - 10 * day).toISOString(),
      reviewedAt: new Date(now.getTime() - 9 * day).toISOString(),
      reviewedBy: 'admin_1'
    }
  );

  // 6. Transactions
  transactions.push(
    // Earnings
    {
      id: 'tx_earning_1',
      userId: 'clip_1',
      type: 'SUBMISSION_REWARD_APPROVED',
      amount: 937500,
      description: 'Reward for: Lancelot Fast Hand Skin Collector',
      status: 'completed',
      date: new Date(now.getTime() - 14 * day).toISOString()
    },
    // Withdrawals
    {
      id: 'tx_withdraw_1',
      userId: 'clip_1',
      type: 'WITHDRAW_REQUEST',
      amount: -1000000,
      description: 'Withdrawal request to Main Bank (BCA)',
      status: 'PENDING',
      date: new Date(now.getTime() - 12 * hour).toISOString()
    },
    {
      id: 'tx_withdraw_2',
      userId: 'clip_1',
      type: 'WITHDRAW_APPROVED',
      amount: -500000,
      description: 'Withdrawal approved',
      status: 'completed',
      date: new Date(now.getTime() - 4 * day).toISOString()
    }
  );

  // 7. Influencer Profiles (for review)
  influencerProfiles.push({
    id: 'prof_new',
    userId: 'inf_2',
    influencerName: 'Beauty Grace',
    socialPlatform: 'INSTAGRAM',
    socialHandle: '@beauty_grace',
    followers: 550000,
    niche: 'Lifestyle & Beauty',
    status: 'VERIFIED',
    submittedAt: new Date(now.getTime() - 16 * day).toISOString(),
    reviewedAt: new Date(now.getTime() - 15 * day).toISOString()
  });

  console.log(`Seeded: ${users.length} users, ${campaigns.length} campaigns, ${submissions.length} submissions, ${transactions.length} transactions`);
};
// Auto-seed on start
seedData();

// Simple JWT-like token system (in production, use proper JWT library)
let tokenCounter = 0;
const tokens = new Map(); // token -> userId

// Helper functions
const generateToken = (userId) => {
  const token = `token_${++tokenCounter}_${Date.now()}`;
  tokens.set(token, userId);
  return token;
};

// Helper to decode JWT without verification (for local dev only)
const decodeJWT = (token) => {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) return null;
    const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString());
    return payload;
  } catch (error) {
    return null;
  }
};

// Verify token - supports both Firebase ID tokens and backend tokens
const verifyToken = async (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  const token = authHeader.substring(7);

  // First, try Firebase token verification with Admin SDK
  let firebaseUid = null;
  let firebaseEmail = null;
  let firebaseName = null;

  try {
    if (admin.apps.length > 0) {
      // If Firebase Admin is initialized, verify token properly
      const decodedToken = await admin.auth().verifyIdToken(token);
      firebaseUid = decodedToken.uid;
      firebaseEmail = decodedToken.email;
      firebaseName = decodedToken.name;
    } else {
      // For local dev without Admin SDK, decode JWT without verification
      // WARNING: This is not secure and should only be used for local development
      const decoded = decodeJWT(token);
      if (decoded && decoded.user_id) {
        firebaseUid = decoded.user_id;
        firebaseEmail = decoded.email;
        firebaseName = decoded.name;
      }
    }
  } catch (firebaseError) {
    // If Firebase verification fails, try to decode anyway (local dev fallback)
    const decoded = decodeJWT(token);
    if (decoded && decoded.user_id) {
      firebaseUid = decoded.user_id;
      firebaseEmail = decoded.email;
      firebaseName = decoded.name;
    }
  }

  // If we have a Firebase UID, use it
  if (firebaseUid) {
    // Find or create user in backend storage
    let user = users.find(u => u.firebaseUid === firebaseUid);

    if (!user) {
      // Check if this is admin email - auto-assign admin role
      const isAdminEmail = firebaseEmail === 'admin@clipflow.com';
      const isInfluencerEmail = firebaseEmail === 'influencer@clipflow.com';

      // Create new user in backend storage
      user = {
        id: `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        firebaseUid: firebaseUid,
        email: firebaseEmail || '',
        name: firebaseName || firebaseEmail?.split('@')[0] || 'User',
        password: '', // No password needed for Firebase auth
        role: isAdminEmail ? 'admin' : (isInfluencerEmail ? 'influencer' : null), // Auto-assign role for default accounts
        balance: 0,
        pendingBalance: 0,
        budget: isInfluencerEmail ? 10000 : 0, // Give influencer starting budget
        status: isAdminEmail ? 'active' : (isInfluencerEmail ? 'verified' : 'active'),
        verified: isAdminEmail || isInfluencerEmail, // Auto-verify default accounts
        influencerStatus: isInfluencerEmail ? 'VERIFIED' : 'NOT_APPLIED',
        createdAt: new Date().toISOString()
      };
      users.push(user);
      console.log('Created new user from Firebase:', user.email, 'Role:', user.role);
    } else {
      // If user exists, check if they should be admin/influencer based on email
      // This handles the case where user was created before this fix
      if (user.email === 'admin@clipflow.com' && user.role !== 'admin') {
        user.role = 'admin';
        user.status = 'active';
        console.log('Updated user to admin:', user.email);
      } else if (user.email === 'influencer@clipflow.com' && user.role !== 'influencer') {
        user.role = 'influencer';
        user.verified = true;
        user.status = 'verified';
        user.influencerStatus = 'VERIFIED';
        if (!user.budget) user.budget = 10000;
        console.log('Updated user to influencer:', user.email);
      }

      // Ensure essential fields exist for all users
      if (user.balance === undefined) user.balance = 0;
      if (user.pendingBalance === undefined) user.pendingBalance = 0;
      if (!user.status) user.status = 'active';
    }

    req.userId = user.id;
    req.firebaseUid = firebaseUid;
    return next();
  }

  // Fallback to backend token system (for backward compatibility)
  const userId = tokens.get(token);
  if (userId) {
    req.userId = userId;
    return next();
  }

  // Both failed
  return res.status(401).json({ error: 'Invalid token' });
};

const requireRole = (roles) => {
  return (req, res, next) => {
    const user = users.find(u => u.id === req.userId);
    if (!user || !roles.includes(user.role)) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    next();
  };
};

// Require verified influencer for campaign creation
const requireVerifiedInfluencer = () => {
  return (req, res, next) => {
    const user = users.find(u => u.id === req.userId);
    if (!user) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    if (user.role === 'influencer' && !user.verified) {
      return res.status(403).json({ error: 'Only verified influencers can create campaigns' });
    }
    next();
  };
};

const requireRoleOrOwner = (roles, ownerCheck) => {
  return (req, res, next) => {
    const user = users.find(u => u.id === req.userId);
    if (!user) {
      return res.status(403).json({ error: 'Forbidden' });
    }

    // Check if user has required role
    if (roles.includes(user.role)) {
      return next();
    }

    // Check if user is owner (for influencer editing their own campaigns)
    if (ownerCheck && ownerCheck(req, user)) {
      return next();
    }

    return res.status(403).json({ error: 'Forbidden' });
  };
};

// Audit log helper
const logAudit = (adminId, action, details) => {
  auditLogs.push({
    id: `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    adminId,
    action,
    details,
    timestamp: new Date().toISOString()
  });
};

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', message: 'Server is running' });
});

// ==================== AUTHENTICATION ====================

// Register
app.post('/api/auth/register', (req, res) => {
  const { email, password, name } = req.body;

  if (!email || !password || !name) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  if (users.find(u => u.email === email)) {
    return res.status(400).json({ error: 'User already exists' });
  }

  const user = {
    id: `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    email,
    password, // In production, hash this!
    name,
    role: null, // No role initially - user must choose
    balance: 0,
    pendingBalance: 0,
    budget: 0, // For influencer: campaign budget
    status: 'active', // active, suspended, blacklisted, pending, verified
    verified: false, // For influencers: true if verified
    influencerStatus: 'NOT_APPLIED', // NOT_APPLIED, PENDING_REVIEW, VERIFIED, REJECTED
    createdAt: new Date().toISOString()
  };

  users.push(user);
  const token = generateToken(user.id);

  res.status(201).json({
    token,
    user: {
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role
    }
  });
});

// Login
app.post('/api/auth/login', (req, res) => {
  const { email, password } = req.body;

  if (!email || !password) {
    return res.status(400).json({ error: 'Missing email or password' });
  }

  const user = users.find(u => u.email === email && u.password === password);
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  if (user.status !== 'active') {
    return res.status(403).json({ error: 'Account is suspended or blacklisted' });
  }

  const token = generateToken(user.id);

  res.json({
    token,
    user: {
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role
    }
  });
});

// Get current user
app.get('/api/auth/me', verifyToken, async (req, res) => {
  try {
    const user = users.find(u => u.id === req.userId);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // If user has Firebase UID and Admin SDK is available, try to get latest info
    // SKIP for dummy users (starting with firebase_) to avoid API errors
    if (user.firebaseUid && !user.firebaseUid.startsWith('firebase_') &&
      typeof admin !== 'undefined' && admin.apps && admin.apps.length > 0) {
      try {
        const firebaseUser = await admin.auth().getUser(user.firebaseUid);
        // Update email if changed in Firebase
        if (firebaseUser.email && firebaseUser.email !== user.email) {
          user.email = firebaseUser.email;
        }
        if (firebaseUser.displayName && firebaseUser.displayName !== user.name) {
          user.name = firebaseUser.displayName;
        }
      } catch (error) {
        // If Firebase user not found, continue with backend user data
        // Only log warning if it's not a "not found" error
        if (error.code !== 'auth/user-not-found') {
          console.warn('Firebase sync failed:', error.message);
        }
      }
    }

    res.json({
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role,
      balance: user.balance,
      pendingBalance: user.pendingBalance,
      budget: user.budget || 0,
      status: user.status,
      verified: user.verified || false,
      influencerStatus: user.influencerStatus || 'NOT_APPLIED'
    });
  } catch (err) {
    console.error('Critical Error in /api/auth/me:', err);
    res.status(500).json({ error: 'Internal Server Error: ' + err.message });
  }
});

// ==================== CAMPAIGNS ====================

// Get all campaigns (marketplace - only public ACTIVE campaigns)
// Marketplace doesn't require auth, but admin view does
app.get('/api/campaigns', async (req, res) => {
  try {
    const activeOnly = req.query.active === 'true';
    const marketplace = req.query.marketplace === 'true'; // For clippers to see available campaigns
    let filteredCampaigns = campaigns;

    // Try to get user if token is provided (for admin view)
    let user = null;
    let isAdmin = false;
    try {
      const authHeader = req.headers.authorization;
      if (authHeader && authHeader.startsWith('Bearer ')) {
        const token = authHeader.substring(7);

        // Try Firebase token verification
        let firebaseUid = null;
        try {
          if (admin.apps.length > 0) {
            const decodedToken = await admin.auth().verifyIdToken(token);
            firebaseUid = decodedToken.uid;
          } else {
            const decoded = decodeJWT(token);
            if (decoded && decoded.user_id) {
              firebaseUid = decoded.user_id;
            }
          }
        } catch (firebaseError) {
          const decoded = decodeJWT(token);
          if (decoded && decoded.user_id) {
            firebaseUid = decoded.user_id;
          }
        }

        if (firebaseUid) {
          user = users.find(u => u.firebaseUid === firebaseUid);
        }

        // Try backend token as fallback
        if (!user) {
          const userId = tokens.get(token);
          if (userId) {
            user = users.find(u => u.id === userId);
          }
        }

        isAdmin = user && user.role === 'admin';
      }
    } catch (e) {
      // If auth fails, continue without user (for marketplace)
      console.warn('Auth check failed for campaigns endpoint:', e.message);
    }

    if (marketplace) {
      // Only show public, ACTIVE campaigns (no auth required)
      const now = new Date();
      console.log('MARKETPLACE DEBUG: Checking campaigns at', now.toISOString());
      console.log('Total campaigns in memory:', campaigns.length);

      filteredCampaigns = campaigns.filter(c => {
        const isStatusActive = c.status === 'ACTIVE';
        const isPublic = c.isPublic;
        const hasEndDate = !!c.endDate;
        const isNotExpired = !c.endDate || new Date(c.endDate) > now;
        const hasBudget = !(c.remainingBudget <= 0 && c.autoCloseOnBudgetExhausted);

        // Debug
        console.log(`Checking campaign ${c.id} (${c.title}):`, {
          status: c.status,
          isPublic: c.isPublic,
          endDate: c.endDate,
          isNotExpired,
          remainingBudget: c.remainingBudget,
          autoClose: c.autoCloseOnBudgetExhausted
        });

        if (c.status !== 'ACTIVE' || !c.isPublic) return false;
        if (c.endDate && new Date(c.endDate) <= now) return false;
        if (c.remainingBudget <= 0 && c.autoCloseOnBudgetExhausted) return false;
        return true;
      });

      // Return public data only (no sensitive info)
      filteredCampaigns = filteredCampaigns.map(c => ({
        id: c.id,
        title: c.title,
        influencerName: c.influencerName,
        description: c.description,
        thumbnail: c.thumbnail,
        allowedPlatforms: c.allowedPlatforms,
        ratePer1kViews: c.ratePer1kViews,
        minEligibleViews: c.minEligibleViews,
        maxPayableViewsPerClip: c.maxPayableViewsPerClip,
        remainingBudget: c.remainingBudget,
        endDate: c.endDate,
        startDate: c.startDate,
        contentGuidelines: c.contentGuidelines,
        captionRequirements: c.captionRequirements,
        hashtagRequirements: c.hashtagRequirements,
        prohibitedContent: c.prohibitedContent,
        allowUnlimitedClippers: c.allowUnlimitedClippers,
        maxClippers: c.maxClippers,
        maxClipsPerUser: c.maxClipsPerUser,
        clippers: c.clippers,
        submissions: c.submissions,
        createdAt: c.createdAt
      }));
    } else if (activeOnly) {
      const now = new Date();
      filteredCampaigns = campaigns.filter(c => {
        if (c.endDate) {
          const deadline = new Date(c.endDate);
          if (deadline <= now) return false;
        }
        return c.status === 'ACTIVE';
      });
    } else {
      // For admin, show all campaigns including DRAFT
      // For others, filter based on role
      if (!isAdmin) {
        // Non-admin users only see ACTIVE campaigns they created or are part of
        const userId = user ? user.id : null;
        filteredCampaigns = campaigns.filter(c => {
          if (c.status === 'ACTIVE') return true;
          if (userId && c.createdBy === userId) return true; // Can see own campaigns
          return false;
        });
      }
      // Admin sees all campaigns
    }

    console.log('GET /api/campaigns:', {
      totalCampaigns: campaigns.length,
      filteredCampaigns: filteredCampaigns.length,
      marketplace,
      activeOnly,
      isAdmin,
      userId: user ? user.id : 'none'
    });

    res.json({ campaigns: filteredCampaigns });
  } catch (error) {
    console.error('Error fetching campaigns:', error);
    res.status(500).json({ error: 'Internal server error: ' + error.message });
  }
});

// Get single campaign
app.get('/api/campaigns/:id', (req, res) => {
  const campaign = campaigns.find(c => c.id === req.params.id);
  if (!campaign) {
    return res.status(404).json({ error: 'Campaign not found' });
  }
  res.json({ campaign });
});

// Create campaign (Admin or Verified Influencer)
app.post('/api/campaigns', verifyToken, requireRoleOrOwner(['admin', 'influencer'], null), requireVerifiedInfluencer(), (req, res) => {
  const {
    title,
    influencerName,
    description,
    allowedPlatforms, // Array: ['tiktok', 'instagram', 'facebook']
    ratePer1kViews, // Rate per 1,000 views
    minEligibleViews, // Minimum views required
    maxPayableViewsPerClip, // Optional cap per clip
    totalBudget, // Total campaign budget
    contentGuidelines,
    captionRequirements,
    hashtagRequirements,
    prohibitedContent,
    startDate, // Default: now
    endDate, // Optional
    autoCloseOnBudgetExhausted, // Boolean
    isPublic, // Public or private
    allowUnlimitedClippers, // Boolean
    maxClippers, // If not unlimited
    maxClipsPerUser // Optional limit
  } = req.body;

  // Validation
  if (!title || !influencerName || !ratePer1kViews || !minEligibleViews || !totalBudget) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  if (!allowedPlatforms || !Array.isArray(allowedPlatforms) || allowedPlatforms.length === 0) {
    return res.status(400).json({ error: 'At least one platform must be selected' });
  }

  const validPlatforms = ['tiktok', 'instagram', 'facebook'];
  const invalidPlatforms = allowedPlatforms.filter(p => !validPlatforms.includes(p.toLowerCase()));
  if (invalidPlatforms.length > 0) {
    return res.status(400).json({ error: `Invalid platforms: ${invalidPlatforms.join(', ')}` });
  }

  if (ratePer1kViews <= 0 || minEligibleViews <= 0 || totalBudget <= 0) {
    return res.status(400).json({ error: 'Rate, minimum views, and budget must be greater than 0' });
  }

  // Check budget for influencer
  const user = users.find(u => u.id === req.userId);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  if (user.role === 'influencer') {
    if (!user.verified) {
      return res.status(403).json({ error: 'Only verified influencers can create campaigns' });
    }
    if ((user.budget || 0) < totalBudget) {
      return res.status(400).json({ error: 'Insufficient wallet balance. Please top up first.' });
    }
    // Reserve budget (don't deduct yet, will deduct when campaign becomes ACTIVE)
    user.budget = (user.budget || 0) - totalBudget;
  }

  try {
    const campaign = {
      id: `campaign_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      title,
      influencerName,
      description: description || '',
      thumbnail: req.body.thumbnail || null,
      allowedPlatforms: allowedPlatforms.map(p => p.toLowerCase()),
      ratePer1kViews: parseFloat(ratePer1kViews),
      minEligibleViews: parseInt(minEligibleViews),
      maxPayableViewsPerClip: maxPayableViewsPerClip ? parseInt(maxPayableViewsPerClip) : null,
      totalBudget: parseFloat(totalBudget),
      reservedBudget: parseFloat(totalBudget), // Initially all budget is reserved
      paidBudget: 0,
      remainingBudget: parseFloat(totalBudget),
      // Campaign rules
      contentGuidelines: contentGuidelines || '',
      captionRequirements: captionRequirements || '',
      hashtagRequirements: hashtagRequirements || '',
      prohibitedContent: prohibitedContent || '',
      // Timeline
      startDate: startDate ? new Date(startDate).toISOString() : new Date().toISOString(),
      endDate: endDate ? new Date(endDate).toISOString() : null,
      autoCloseOnBudgetExhausted: autoCloseOnBudgetExhausted !== false, // Default true
      // Visibility
      isPublic: isPublic !== false, // Default true
      allowUnlimitedClippers: allowUnlimitedClippers !== false, // Default true
      maxClippers: allowUnlimitedClippers ? null : (maxClippers ? parseInt(maxClippers) : null),
      maxClipsPerUser: maxClipsPerUser ? parseInt(maxClipsPerUser) : null,
      // Status
      status: 'DRAFT', // DRAFT, ACTIVE, PAUSED, COMPLETED, CANCELLED
      // Stats
      clippers: 0,
      submissions: 0,
      totalViews: 0,
      participants: [], // Array of participant IDs
      createdBy: req.userId,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    campaigns.push(campaign);
    console.log('Campaign created:', {
      id: campaign.id,
      title: campaign.title,
      status: campaign.status,
      influencerName: campaign.influencerName,
      totalCampaigns: campaigns.length
    });

    if (user.role === 'admin') {
      logAudit(req.userId, 'CREATE_CAMPAIGN', { campaignId: campaign.id, title: campaign.title });
    }

    res.status(201).json({ campaign });
  } catch (error) {
    console.error('Error creating campaign:', error);
    res.status(500).json({ error: 'Internal server error: ' + error.message });
  }
});

// Update campaign (Admin or Influencer - own campaigns only)
app.put('/api/campaigns/:id', verifyToken, requireRoleOrOwner(['admin'], (req, user) => {
  const campaign = campaigns.find(c => c.id === req.params.id);
  return campaign && campaign.createdBy === user.id && user.role === 'influencer';
}), (req, res) => {
  const campaign = campaigns.find(c => c.id === req.params.id);
  if (!campaign) {
    return res.status(404).json({ error: 'Campaign not found' });
  }

  const user = users.find(u => u.id === req.userId);

  // Influencer can only edit their own campaigns and cannot change status
  if (user.role === 'influencer' && campaign.createdBy !== req.userId) {
    return res.status(403).json({ error: 'You can only edit your own campaigns' });
  }

  const oldStatus = campaign.status;
  const updateData = { ...req.body };

  // Influencer cannot change status
  if (user.role === 'influencer') {
    delete updateData.status;
  }

  Object.assign(campaign, {
    ...updateData,
    id: campaign.id,
    createdAt: campaign.createdAt
  });

  if (user.role === 'admin') {
    if (oldStatus !== campaign.status) {
      logAudit(req.userId, 'UPDATE_CAMPAIGN_STATUS', {
        campaignId: campaign.id,
        oldStatus,
        newStatus: campaign.status
      });
    } else {
      logAudit(req.userId, 'UPDATE_CAMPAIGN', { campaignId: campaign.id });
    }
  }

  res.json({ campaign });
});

// Activate campaign (change from DRAFT to ACTIVE) - Influencer or Admin
app.patch('/api/campaigns/:id/activate', verifyToken, requireRoleOrOwner(['admin'], (req, user) => {
  const campaign = campaigns.find(c => c.id === req.params.id);
  return campaign && campaign.createdBy === user.id && user.role === 'influencer';
}), (req, res) => {
  const campaign = campaigns.find(c => c.id === req.params.id);
  if (!campaign) {
    return res.status(404).json({ error: 'Campaign not found' });
  }

  if (campaign.status !== 'DRAFT') {
    return res.status(400).json({ error: 'Only DRAFT campaigns can be activated' });
  }

  const user = users.find(u => u.id === req.userId);
  if (user.role === 'influencer' && campaign.createdBy !== req.userId) {
    return res.status(403).json({ error: 'You can only activate your own campaigns' });
  }

  campaign.status = 'ACTIVE';
  campaign.updatedAt = new Date().toISOString();

  if (user.role === 'admin') {
    logAudit(req.userId, 'ACTIVATE_CAMPAIGN', { campaignId: campaign.id });
  }

  res.json({ campaign });
});

// Pause/Resume campaign - Influencer (own campaigns) or Admin
app.patch('/api/campaigns/:id/status', verifyToken, requireRoleOrOwner(['admin'], (req, user) => {
  const campaign = campaigns.find(c => c.id === req.params.id);
  return campaign && campaign.createdBy === user.id && user.role === 'influencer';
}), (req, res) => {
  const { status } = req.body; // 'ACTIVE', 'PAUSED', 'COMPLETED', 'CANCELLED'
  if (!['ACTIVE', 'PAUSED', 'COMPLETED', 'CANCELLED'].includes(status)) {
    return res.status(400).json({ error: 'Invalid status' });
  }

  const campaign = campaigns.find(c => c.id === req.params.id);
  if (!campaign) {
    return res.status(404).json({ error: 'Campaign not found' });
  }

  const user = users.find(u => u.id === req.userId);
  if (user.role === 'influencer' && campaign.createdBy !== req.userId) {
    return res.status(403).json({ error: 'You can only manage your own campaigns' });
  }

  // Prevent changing from COMPLETED or CANCELLED
  if (['COMPLETED', 'CANCELLED'].includes(campaign.status) && status !== campaign.status) {
    return res.status(400).json({ error: 'Cannot change status of completed or cancelled campaigns' });
  }

  const oldStatus = campaign.status;
  campaign.status = status;
  campaign.updatedAt = new Date().toISOString();

  if (user.role === 'admin') {
    logAudit(req.userId, 'UPDATE_CAMPAIGN_STATUS', {
      campaignId: campaign.id,
      oldStatus,
      newStatus: status
    });
  }

  res.json({ campaign });
});

// Delete campaign (Admin only)
app.delete('/api/campaigns/:id', verifyToken, requireRole(['admin']), (req, res) => {
  const index = campaigns.findIndex(c => c.id === req.params.id);
  if (index === -1) {
    return res.status(404).json({ error: 'Campaign not found' });
  }

  const campaign = campaigns[index];
  campaigns.splice(index, 1);
  logAudit(req.userId, 'DELETE_CAMPAIGN', { campaignId: campaign.id, title: campaign.title });

  res.json({ message: 'Campaign deleted' });
});

// ==================== SUBMISSIONS ====================

// Get submissions (filtered by user role)
app.get('/api/submissions', verifyToken, (req, res) => {
  const user = users.find(u => u.id === req.userId);
  let filteredSubmissions = submissions;

  if (user.role === 'clipper') {
    filteredSubmissions = submissions.filter(s => s.userId === req.userId);
  }

  // Add user info for admin
  if (user.role === 'admin') {
    filteredSubmissions = filteredSubmissions.map(s => {
      const clipper = users.find(u => u.id === s.userId);
      return {
        ...s,
        clipperName: clipper?.name || 'Unknown',
        clipperEmail: clipper?.email || 'Unknown'
      };
    });
  }

  // For influencer: only show submissions from their campaigns, but NO clipper info
  if (user.role === 'influencer') {
    const influencerCampaigns = campaigns.filter(c => c.createdBy === req.userId);
    const influencerCampaignIds = influencerCampaigns.map(c => c.id);
    filteredSubmissions = filteredSubmissions.filter(s =>
      influencerCampaignIds.includes(s.campaignId)
    );
    // Remove clipper info for influencer
    filteredSubmissions = filteredSubmissions.map(s => {
      const { userId, ...submissionWithoutUserId } = s;
      return submissionWithoutUserId;
    });
  }

  res.json({ submissions: filteredSubmissions });
});

// Get single submission
app.get('/api/submissions/:id', verifyToken, (req, res) => {
  const submission = submissions.find(s => s.id === req.params.id);
  if (!submission) {
    return res.status(404).json({ error: 'Submission not found' });
  }

  const user = users.find(u => u.id === req.userId);
  if (user.role === 'clipper' && submission.userId !== req.userId) {
    return res.status(403).json({ error: 'Forbidden' });
  }

  // Add clipper info for admin
  if (user.role === 'admin') {
    const clipper = users.find(u => u.id === submission.userId);
    submission.clipper = {
      id: clipper?.id,
      name: clipper?.name,
      email: clipper?.email,
      status: clipper?.status,
      totalSubmissions: submissions.filter(s => s.userId === submission.userId).length,
      approvedSubmissions: submissions.filter(s => s.userId === submission.userId && s.status === 'approved').length
    };
  }

  res.json({ submission });
});

// Create submission
app.post('/api/submissions', verifyToken, (req, res) => {
  const {
    platform, // YOUTUBE, TIKTOK, INSTAGRAM, FACEBOOK
    videoUrl,
    campaignId,
    title,
    thumbnail,
    views,
    likes,
    duration,
    channelName,
    channelId,
    uploadDate, // For non-YouTube
    isOriginal, // For non-YouTube
    note // Optional
  } = req.body;

  if (!videoUrl || !campaignId) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  const selectedPlatform = (platform || 'YOUTUBE').toUpperCase();
  const validPlatforms = ['YOUTUBE', 'TIKTOK', 'INSTAGRAM', 'FACEBOOK'];
  if (!validPlatforms.includes(selectedPlatform)) {
    return res.status(400).json({ error: 'Invalid platform' });
  }

  const user = users.find(u => u.id === req.userId);
  if (user.status !== 'active') {
    return res.status(403).json({ error: 'Account is suspended or blacklisted' });
  }

  const campaign = campaigns.find(c => c.id === campaignId);
  if (!campaign) {
    return res.status(404).json({ error: 'Campaign not found' });
  }

  if (campaign.status !== 'ACTIVE') {
    return res.status(400).json({ error: 'Campaign is not active' });
  }

  // Check if platform is allowed in campaign
  if (campaign.allowedPlatforms && campaign.allowedPlatforms.length > 0) {
    const platformLower = selectedPlatform.toLowerCase();
    if (!campaign.allowedPlatforms.includes(platformLower)) {
      return res.status(400).json({ error: `Platform ${selectedPlatform} is not allowed for this campaign` });
    }
  }

  // Validate URL format
  const urlPatterns = {
    YOUTUBE: [/youtube\.com\/watch/, /youtu\.be\//],
    TIKTOK: [/tiktok\.com/],
    INSTAGRAM: [/instagram\.com\/reel/, /instagram\.com\/p/],
    FACEBOOK: [/facebook\.com\/watch/, /fb\.watch/],
  };
  const isValidUrl = urlPatterns[selectedPlatform].some(pattern => pattern.test(videoUrl));
  if (!isValidUrl) {
    return res.status(400).json({ error: `Invalid ${selectedPlatform} URL format` });
  }

  // Check for duplicate URL across all submissions
  const existingSubmission = submissions.find(s => s.videoUrl === videoUrl);
  if (existingSubmission) {
    return res.status(400).json({ error: 'This video URL has already been submitted' });
  }

  // Check if user has joined the campaign (if required)
  if (campaign.participants && !campaign.participants.includes(req.userId)) {
    return res.status(403).json({ error: 'You must join the campaign first' });
  }

  // Check max clips per user
  if (campaign.maxClipsPerUser) {
    const userSubmissions = submissions.filter(s =>
      s.campaignId === campaignId && s.userId === req.userId
    );
    if (userSubmissions.length >= campaign.maxClipsPerUser) {
      return res.status(400).json({ error: `Maximum ${campaign.maxClipsPerUser} clips per user reached` });
    }
  }

  // For non-YouTube, validate additional fields
  if (selectedPlatform !== 'YOUTUBE') {
    if (!uploadDate) {
      return res.status(400).json({ error: 'Upload date is required for non-YouTube submissions' });
    }
    if (!isOriginal) {
      return res.status(400).json({ error: 'You must confirm the video is original' });
    }
  }

  // Calculate potential reward (for YouTube with views, for others will be calculated after proof)
  let eligibleViews = 0;
  let potentialReward = 0;

  if (selectedPlatform === 'YOUTUBE' && views) {
    eligibleViews = Math.min(
      parseInt(views) || 0,
      campaign.maxPayableViewsPerClip || parseInt(views) || 0
    );
    potentialReward = eligibleViews >= campaign.minEligibleViews
      ? (eligibleViews / 1000) * campaign.ratePer1kViews
      : 0;
  }

  // Determine initial status
  let initialStatus = 'SUBMITTED';
  if (selectedPlatform === 'YOUTUBE') {
    // YouTube goes directly to pending (old flow)
    initialStatus = 'pending';
  } else {
    // Non-YouTube: SUBMITTED â†’ will move to WAITING_VIEW_CHECK after lock period
    initialStatus = 'SUBMITTED';
  }

  const submission = {
    id: `submission_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    userId: req.userId,
    campaignId,
    platform: selectedPlatform,
    videoUrl,
    title: title || 'Untitled Clip',
    thumbnail: thumbnail || 'https://images.unsplash.com/photo-1542751371-adc38448a05e?w=400&h=300&fit=crop',
    views: selectedPlatform === 'YOUTUBE' ? (parseInt(views) || 0) : 0,
    likes: selectedPlatform === 'YOUTUBE' ? (parseInt(likes) || 0) : 0,
    duration: duration || '0:00',
    channelName: channelName || '',
    channelId: channelId || '',
    uploadDate: selectedPlatform !== 'YOUTUBE' ? uploadDate : null,
    isOriginal: selectedPlatform !== 'YOUTUBE' ? isOriginal : true,
    note: note || null,
    status: initialStatus,
    flagged: false,
    flagReason: null,
    reward: potentialReward,
    potentialReward: potentialReward,
    eligibleViews: eligibleViews,
    submittedAt: new Date().toISOString(),
    lockUntil: selectedPlatform !== 'YOUTUBE'
      ? new Date(Date.now() + 48 * 60 * 60 * 1000).toISOString() // 48 hours from now
      : null,
    reviewedAt: null,
    reviewedBy: null,
    rejectionReason: null,
    viewHistory: selectedPlatform === 'YOUTUBE'
      ? [{ views: parseInt(views) || 0, timestamp: new Date().toISOString() }]
      : [],
    ipAddress: req.ip || req.headers['x-forwarded-for'] || 'unknown',
    userAgent: req.headers['user-agent'] || 'unknown'
  };

  submissions.push(submission);
  campaign.submissions = (campaign.submissions || 0) + 1;
  if (selectedPlatform === 'YOUTUBE') {
    campaign.totalViews += submission.views;
  }

  res.status(201).json({ submission });
});

// Get my submissions (Clipper)
app.get('/api/submissions/my', verifyToken, requireRole(['clipper']), (req, res) => {
  const userSubmissions = submissions
    .filter(s => s.userId === req.userId)
    .map(s => {
      const proof = submissionProofs.find(p => p.submissionId === s.id);
      return {
        ...s,
        proof: proof || null,
        canSubmitProof: s.platform !== 'YOUTUBE' &&
          s.status === 'SUBMITTED' &&
          s.lockUntil &&
          new Date(s.lockUntil) <= new Date()
      };
    })
    .sort((a, b) => new Date(b.submittedAt) - new Date(a.submittedAt));

  res.json({ submissions: userSubmissions });
});

// Submit proof for non-YouTube submission
app.post('/api/submissions/:id/proof', verifyToken, requireRole(['clipper']), (req, res) => {
  const {
    analyticsScreenshot, // URL to uploaded image
    videoPageScreenshot, // URL to uploaded image
    screenRecording, // Optional URL
    totalViews,
    proofDate, // Date when proof was taken
    proofTime // Time when proof was taken
  } = req.body;

  if (!analyticsScreenshot || !videoPageScreenshot || !totalViews) {
    return res.status(400).json({ error: 'Missing required proof fields' });
  }

  const submission = submissions.find(s => s.id === req.params.id);
  if (!submission) {
    return res.status(404).json({ error: 'Submission not found' });
  }

  if (submission.userId !== req.userId) {
    return res.status(403).json({ error: 'You can only submit proof for your own submissions' });
  }

  if (submission.platform === 'YOUTUBE') {
    return res.status(400).json({ error: 'Proof submission is not required for YouTube videos' });
  }

  if (submission.status !== 'SUBMITTED' && submission.status !== 'WAITING_VIEW_CHECK') {
    return res.status(400).json({ error: `Cannot submit proof for submission with status: ${submission.status}` });
  }

  // Check if lock period has passed
  if (submission.lockUntil && new Date(submission.lockUntil) > new Date()) {
    const hoursLeft = Math.ceil((new Date(submission.lockUntil) - new Date()) / (1000 * 60 * 60));
    return res.status(400).json({
      error: `Please wait ${hoursLeft} more hours before submitting proof`,
      lockUntil: submission.lockUntil
    });
  }

  // Check if proof already submitted
  const existingProof = submissionProofs.find(p => p.submissionId === submission.id);
  if (existingProof) {
    return res.status(400).json({ error: 'Proof has already been submitted for this submission' });
  }

  const campaign = campaigns.find(c => c.id === submission.campaignId);
  if (!campaign) {
    return res.status(404).json({ error: 'Campaign not found' });
  }

  // Validate minimum views
  const views = parseInt(totalViews);
  if (views < campaign.minEligibleViews) {
    return res.status(400).json({
      error: `Views (${views}) are below minimum requirement (${campaign.minEligibleViews})`
    });
  }

  // Calculate reward
  const eligibleViews = Math.min(
    views,
    campaign.maxPayableViewsPerClip || views
  );
  const reward = (eligibleViews / 1000) * campaign.ratePer1kViews;

  // Create proof record
  const proof = {
    id: `proof_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    submissionId: submission.id,
    analyticsScreenshot,
    videoPageScreenshot,
    screenRecording: screenRecording || null,
    totalViews: views,
    proofDate: proofDate || new Date().toISOString().split('T')[0],
    proofTime: proofTime || new Date().toTimeString().split(' ')[0],
    submittedAt: new Date().toISOString(),
    // Image hash for duplicate detection (in production, calculate from image)
    imageHash: `${analyticsScreenshot}_${videoPageScreenshot}`.substring(0, 50)
  };

  submissionProofs.push(proof);

  // Update submission
  submission.status = 'WAITING_REVIEW';
  submission.views = views;
  submission.eligibleViews = eligibleViews;
  submission.potentialReward = reward;
  submission.reward = reward;
  submission.viewHistory = [{ views, timestamp: new Date().toISOString() }];

  // Update campaign stats
  campaign.totalViews += views;

  res.status(201).json({ proof, submission });
});

// Join campaign (Clipper)
app.post('/api/campaigns/:id/join', verifyToken, requireRole(['clipper']), (req, res) => {
  const campaign = campaigns.find(c => c.id === req.params.id);
  if (!campaign) {
    return res.status(404).json({ error: 'Campaign not found' });
  }

  if (campaign.status !== 'ACTIVE') {
    return res.status(400).json({ error: 'Campaign is not active' });
  }

  if (!campaign.isPublic) {
    return res.status(403).json({ error: 'This is a private campaign' });
  }

  // Check if campaign allows more clippers
  if (!campaign.allowUnlimitedClippers && campaign.maxClippers) {
    if (campaign.clippers >= campaign.maxClippers) {
      return res.status(400).json({ error: 'Campaign has reached maximum clippers' });
    }
  }

  // Check if user already joined
  if (campaign.participants && campaign.participants.includes(req.userId)) {
    return res.status(400).json({ error: 'You have already joined this campaign' });
  }

  if (!campaign.participants) {
    campaign.participants = [];
  }
  campaign.participants.push(req.userId);
  campaign.clippers = campaign.participants.length;

  res.json({ message: 'Successfully joined campaign', campaign });
});

// Approve/Reject submission (Admin or Influencer - own campaigns)
app.patch('/api/submissions/:id/approve', verifyToken, requireRoleOrOwner(['admin'], (req, user) => {
  const submission = submissions.find(s => s.id === req.params.id);
  if (!submission) return false;
  const campaign = campaigns.find(c => c.id === submission.campaignId);
  return campaign && campaign.createdBy === user.id && user.role === 'influencer';
}), (req, res) => {
  const { status, reason } = req.body; // 'approved' or 'rejected' or 'APPROVED' or 'REJECTED'

  // Support both old and new status formats
  const normalizedStatus = status.toUpperCase();
  if (!['APPROVED', 'REJECTED', 'APPROVE', 'REJECT'].includes(normalizedStatus)) {
    return res.status(400).json({ error: 'Invalid status. Use: approved or rejected' });
  }

  const finalStatus = normalizedStatus === 'APPROVE' ? 'APPROVED' :
    normalizedStatus === 'REJECT' ? 'REJECTED' : normalizedStatus;

  const submission = submissions.find(s => s.id === req.params.id);
  if (!submission) {
    return res.status(404).json({ error: 'Submission not found' });
  }

  // Validate status transition
  const validTransitions = {
    'pending': ['APPROVED', 'REJECTED'],
    'WAITING_REVIEW': ['APPROVED', 'REJECTED'],
    'SUBMITTED': ['REJECTED'], // Can reject before proof
    'WAITING_VIEW_CHECK': ['REJECTED'] // Can reject if proof is invalid
  };

  const allowedStatuses = validTransitions[submission.status] || [];
  if (!allowedStatuses.includes(finalStatus)) {
    return res.status(400).json({
      error: `Cannot transition from ${submission.status} to ${finalStatus}`
    });
  }

  // For non-YouTube, ensure proof is submitted before approval
  if (finalStatus === 'APPROVED' && submission.platform !== 'YOUTUBE') {
    const proof = submissionProofs.find(p => p.submissionId === submission.id);
    if (!proof) {
      return res.status(400).json({ error: 'Proof must be submitted before approval' });
    }
    if (submission.status !== 'WAITING_REVIEW') {
      return res.status(400).json({ error: 'Submission must be in WAITING_REVIEW status' });
    }
  }

  const oldStatus = submission.status;
  submission.status = finalStatus;
  submission.reviewedAt = new Date().toISOString();
  submission.reviewedBy = req.userId;

  if (finalStatus === 'REJECTED') {
    submission.rejectionReason = reason || 'No reason provided';
  }

  if (finalStatus === 'APPROVED' || status === 'approved') {
    const clipper = users.find(u => u.id === submission.userId);
    const campaign = campaigns.find(c => c.id === submission.campaignId);

    if (campaign && clipper) {
      // Use already calculated reward from submission
      const payment = submission.reward || submission.potentialReward || 0;

      if (payment > 0) {
        // Check if campaign has remaining budget
        if (campaign.remainingBudget < payment) {
          return res.status(400).json({ error: 'Campaign budget exhausted' });
        }

        // Create transaction: SUBMISSION_REWARD_PENDING
        const pendingTransaction = {
          id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          userId: submission.userId,
          type: 'SUBMISSION_REWARD_PENDING',
          amount: payment,
          description: `Reward for submission: ${submission.title || 'Clip'}`,
          status: 'pending',
          relatedEntityId: submission.id,
          createdAt: new Date().toISOString(),
          date: new Date().toISOString()
        };
        transactions.push(pendingTransaction);

        // Also create approved transaction (immediate approval for now)
        // In production, you might want a review period before moving from pending to approved
        const approvedTransaction = {
          id: `tx_${Date.now() + 1}_${Math.random().toString(36).substr(2, 9)}`,
          userId: submission.userId,
          type: 'SUBMISSION_REWARD_APPROVED',
          amount: payment,
          description: `Reward approved: ${submission.title || 'Clip'}`,
          status: 'completed',
          relatedEntityId: submission.id,
          relatedTransactionId: pendingTransaction.id,
          createdAt: new Date().toISOString(),
          date: new Date().toISOString()
        };
        transactions.push(approvedTransaction);

        campaign.paidBudget = (campaign.paidBudget || 0) + payment;
        campaign.remainingBudget = campaign.remainingBudget - payment;
        campaign.spentBudget = campaign.paidBudget; // For backward compatibility

        // Mark submission as paid
        submission.status = 'PAID';

        // Auto-close if budget exhausted
        if (campaign.remainingBudget <= 0 && campaign.autoCloseOnBudgetExhausted) {
          campaign.status = 'COMPLETED';
          campaign.updatedAt = new Date().toISOString();
        }
      }
    }
  }

  const user = users.find(u => u.id === req.userId);
  if (user.role === 'admin') {
    logAudit(req.userId, `${status.toUpperCase()}_SUBMISSION`, {
      submissionId: submission.id,
      userId: submission.userId,
      reason: reason || null
    });
  }

  res.json({ submission });
});

// Flag submission (Admin only)
app.patch('/api/submissions/:id/flag', verifyToken, requireRole(['admin']), (req, res) => {
  const { flagged, reason } = req.body;

  const submission = submissions.find(s => s.id === req.params.id);
  if (!submission) {
    return res.status(404).json({ error: 'Submission not found' });
  }

  submission.flagged = flagged;
  submission.flagReason = reason || null;

  logAudit(req.userId, flagged ? 'FLAG_SUBMISSION' : 'UNFLAG_SUBMISSION', {
    submissionId: submission.id,
    reason: reason || null
  });

  res.json({ submission });
});

// ==================== WALLET & TRANSACTIONS ====================

// Helper function to calculate wallet balance from transactions (ledger-based)
const calculateWalletBalance = (userId) => {
  const userTransactions = transactions.filter(t => t.userId === userId);

  let availableBalance = 0;
  let pendingBalance = 0;
  let lockedBalance = 0;
  let lifetimeEarned = 0;
  let lifetimeWithdrawn = 0;

  userTransactions.forEach(t => {
    const amount = Math.abs(t.amount);

    switch (t.type) {
      case 'SUBMISSION_REWARD_PENDING':
        pendingBalance += amount;
        lifetimeEarned += amount;
        break;
      case 'SUBMISSION_REWARD_APPROVED':
        availableBalance += amount;
        // Deduct from pending if it was pending before
        const pendingTx = userTransactions.find(pt =>
          pt.type === 'SUBMISSION_REWARD_PENDING' &&
          pt.relatedTransactionId === t.id
        );
        if (pendingTx) {
          pendingBalance -= Math.abs(pendingTx.amount);
        }
        break;
      case 'SUBMISSION_REWARD_REVERSED':
        // Deduct from available or pending
        availableBalance -= amount;
        break;
      case 'WITHDRAW_REQUEST':
        availableBalance -= amount;
        lockedBalance += amount;
        break;
      case 'WITHDRAW_APPROVED':
        lockedBalance -= amount;
        lifetimeWithdrawn += amount;
        break;
      case 'WITHDRAW_REJECTED':
        lockedBalance -= amount;
        availableBalance += amount; // Return to available
        break;
      case 'CAMPAIGN_FUNDING':
        availableBalance -= amount;
        break;
      case 'ADMIN_ADJUSTMENT':
        if (t.amount > 0) {
          availableBalance += amount;
        } else {
          availableBalance -= amount;
        }
        break;
    }
  });

  return {
    availableBalance,
    pendingBalance,
    lockedBalance,
    lifetimeEarned,
    lifetimeWithdrawn
  };
};

// Get wallet info (calculated from transactions)
app.get('/api/wallet', verifyToken, (req, res) => {
  const user = users.find(u => u.id === req.userId);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  const balance = calculateWalletBalance(req.userId);

  res.json({
    balance: balance.availableBalance, // For backward compatibility
    availableBalance: balance.availableBalance,
    pendingBalance: balance.pendingBalance,
    lockedBalance: balance.lockedBalance,
    totalEarned: balance.lifetimeEarned,
    lifetimeEarned: balance.lifetimeEarned,
    totalWithdrawn: balance.lifetimeWithdrawn,
    lifetimeWithdrawn: balance.lifetimeWithdrawn
  });
});

// Get transactions
app.get('/api/transactions', verifyToken, (req, res) => {
  const user = users.find(u => u.id === req.userId);
  let userTransactions = transactions.filter(t => t.userId === req.userId);

  // Admin can see all transactions
  if (user.role === 'admin') {
    userTransactions = transactions;
  }

  userTransactions.sort((a, b) => new Date(b.createdAt || b.date) - new Date(a.createdAt || a.date));

  res.json({ transactions: userTransactions });
});

// Get wallet transactions (with filters)
app.get('/api/wallet/transactions', verifyToken, (req, res) => {
  const user = users.find(u => u.id === req.userId);
  let userTransactions = transactions.filter(t => t.userId === req.userId);

  // Apply filters
  if (req.query.type) {
    userTransactions = userTransactions.filter(t => t.type === req.query.type);
  }
  if (req.query.status) {
    userTransactions = userTransactions.filter(t => t.status === req.query.status);
  }

  userTransactions.sort((a, b) => new Date(b.createdAt || b.date) - new Date(a.createdAt || a.date));

  res.json({ transactions: userTransactions });
});

// ==================== PAYMENT METHODS ====================

// Get payment methods
app.get('/api/wallet/payment-methods', verifyToken, (req, res) => {
  const userMethods = paymentMethods.filter(pm => pm.userId === req.userId);
  res.json({ paymentMethods: userMethods });
});

// Add payment method
app.post('/api/wallet/payment-methods', verifyToken, (req, res) => {
  const { type, label, bankName, accountNumber, accountName, ewalletType, ewalletNumber, ewalletName } = req.body;

  if (!type || !['BANK', 'EWALLET'].includes(type)) {
    return res.status(400).json({ error: 'Invalid payment method type' });
  }

  if (type === 'BANK' && (!bankName || !accountNumber || !accountName)) {
    return res.status(400).json({ error: 'Missing bank details' });
  }

  if (type === 'EWALLET' && (!ewalletType || !ewalletNumber || !ewalletName)) {
    return res.status(400).json({ error: 'Missing e-wallet details' });
  }

  const method = {
    id: `pm_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    userId: req.userId,
    type,
    label: label || (type === 'BANK' ? bankName : ewalletType),
    bankName: type === 'BANK' ? bankName : null,
    accountNumber: type === 'BANK' ? accountNumber : null,
    accountName: type === 'BANK' ? accountName : null,
    ewalletType: type === 'EWALLET' ? ewalletType : null,
    ewalletNumber: type === 'EWALLET' ? ewalletNumber : null,
    ewalletName: type === 'EWALLET' ? ewalletName : null,
    isDefault: paymentMethods.filter(pm => pm.userId === req.userId).length === 0,
    createdAt: new Date().toISOString()
  };

  paymentMethods.push(method);
  res.status(201).json({ paymentMethod: method });
});

// Update payment method
app.put('/api/wallet/payment-methods/:id', verifyToken, (req, res) => {
  const method = paymentMethods.find(pm => pm.id === req.params.id);
  if (!method) {
    return res.status(404).json({ error: 'Payment method not found' });
  }

  if (method.userId !== req.userId) {
    return res.status(403).json({ error: 'Forbidden' });
  }

  const { label, bankName, accountNumber, accountName, ewalletType, ewalletNumber, ewalletName } = req.body;

  Object.assign(method, {
    label: label || method.label,
    bankName: method.type === 'BANK' ? (bankName || method.bankName) : null,
    accountNumber: method.type === 'BANK' ? (accountNumber || method.accountNumber) : null,
    accountName: method.type === 'BANK' ? (accountName || method.accountName) : null,
    ewalletType: method.type === 'EWALLET' ? (ewalletType || method.ewalletType) : null,
    ewalletNumber: method.type === 'EWALLET' ? (ewalletNumber || method.ewalletNumber) : null,
    ewalletName: method.type === 'EWALLET' ? (ewalletName || method.ewalletName) : null,
    updatedAt: new Date().toISOString()
  });

  res.json({ paymentMethod: method });
});

// Delete payment method
app.delete('/api/wallet/payment-methods/:id', verifyToken, (req, res) => {
  const index = paymentMethods.findIndex(pm => pm.id === req.params.id);
  if (index === -1) {
    return res.status(404).json({ error: 'Payment method not found' });
  }

  const method = paymentMethods[index];
  if (method.userId !== req.userId) {
    return res.status(403).json({ error: 'Forbidden' });
  }

  paymentMethods.splice(index, 1);
  res.json({ message: 'Payment method deleted' });
});

// ==================== WITHDRAW REQUESTS ====================

// Create withdraw request
app.post('/api/wallet/withdraw', verifyToken, requireRole(['clipper']), (req, res) => {
  const { amount, paymentMethodId, notes } = req.body;

  if (!amount || !paymentMethodId) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  const withdrawAmount = parseFloat(amount);
  const minWithdraw = 50000; // Rp 50.000

  if (withdrawAmount < minWithdraw) {
    return res.status(400).json({ error: `Minimum withdrawal is Rp ${minWithdraw.toLocaleString('id-ID')}` });
  }

  const user = users.find(u => u.id === req.userId);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  // Calculate balance from transactions
  const balance = calculateWalletBalance(req.userId);

  if (withdrawAmount > balance.availableBalance) {
    return res.status(400).json({ error: 'Insufficient available balance' });
  }

  const paymentMethod = paymentMethods.find(pm => pm.id === paymentMethodId && pm.userId === req.userId);
  if (!paymentMethod) {
    return res.status(404).json({ error: 'Payment method not found' });
  }

  // Check cooldown (prevent rapid withdrawals)
  const recentWithdraw = withdrawRequests
    .filter(w => w.userId === req.userId && w.status === 'PENDING')
    .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))[0];

  if (recentWithdraw) {
    const hoursSinceLastWithdraw = (new Date().getTime() - new Date(recentWithdraw.createdAt).getTime()) / (1000 * 60 * 60);
    if (hoursSinceLastWithdraw < 24) {
      return res.status(400).json({ error: 'Please wait 24 hours between withdrawal requests' });
    }
  }

  // Create withdraw request
  const withdrawRequest = {
    id: `withdraw_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    userId: req.userId,
    amount: withdrawAmount,
    paymentMethodId,
    paymentMethod: paymentMethod,
    notes: notes || null,
    status: 'PENDING',
    createdAt: new Date().toISOString(),
    reviewedAt: null,
    reviewedBy: null,
    rejectionReason: null,
    ipAddress: req.ip || req.headers['x-forwarded-for'] || 'unknown',
    userAgent: req.headers['user-agent'] || 'unknown'
  };

  withdrawRequests.push(withdrawRequest);

  // Create transaction: WITHDRAW_REQUEST
  const transaction = {
    id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    userId: req.userId,
    type: 'WITHDRAW_REQUEST',
    amount: -withdrawAmount, // Negative for withdrawal
    description: `Withdrawal request to ${paymentMethod.label}`,
    status: 'PENDING',
    relatedEntityId: withdrawRequest.id,
    createdAt: new Date().toISOString(),
    date: new Date().toISOString()
  };

  transactions.push(transaction);

  res.status(201).json({ withdrawRequest, transaction });
});

// Get my withdraw requests
app.get('/api/wallet/withdraws', verifyToken, requireRole(['clipper']), (req, res) => {
  const userWithdraws = withdrawRequests
    .filter(w => w.userId === req.userId)
    .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

  res.json({ withdrawRequests: userWithdraws });
});

// Create transaction (for approved submissions - legacy)
app.post('/api/transactions', verifyToken, (req, res) => {
  const { type, amount, description } = req.body;

  if (!type || !amount) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  const user = users.find(u => u.id === req.userId);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  if (type === 'withdrawal') {
    if (user.balance < amount) {
      return res.status(400).json({ error: 'Insufficient balance' });
    }
    user.balance -= amount;
  } else if (type === 'earning') {
    // Move from pending to balance
    if (user.pendingBalance < amount) {
      return res.status(400).json({ error: 'Insufficient pending balance' });
    }
    user.pendingBalance -= amount;
    user.balance += amount;
  }

  const transaction = {
    id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    userId: req.userId,
    type,
    amount: type === 'withdrawal' ? -Math.abs(amount) : Math.abs(amount),
    description: description || '',
    status: type === 'withdrawal' ? 'pending' : 'completed',
    date: new Date().toISOString()
  };

  transactions.push(transaction);
  res.status(201).json({ transaction });
});

// ==================== ADMIN DASHBOARD ====================

// Get admin stats
app.get('/api/admin/stats', verifyToken, requireRole(['admin']), (req, res) => {
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);

  const activeCampaigns = campaigns.filter(c => {
    const deadline = new Date(c.deadline);
    return deadline > now && c.status === 'active';
  });

  const pendingSubmissions = submissions.filter(s => s.status === 'pending');
  const flaggedSubmissions = submissions.filter(s => s.flagged === true);

  const submissionsToday = submissions.filter(s => {
    const submitted = new Date(s.submittedAt);
    return submitted >= today;
  });

  const payoutToday = transactions
    .filter(t => {
      const txDate = new Date(t.date);
      return txDate >= today && t.type === 'withdrawal' && t.status === 'completed';
    })
    .reduce((sum, t) => sum + Math.abs(t.amount), 0);

  const payoutWeek = transactions
    .filter(t => {
      const txDate = new Date(t.date);
      return txDate >= weekAgo && t.type === 'withdrawal' && t.status === 'completed';
    })
    .reduce((sum, t) => sum + Math.abs(t.amount), 0);

  const totalPendingPayout = transactions
    .filter(t => t.type === 'withdrawal' && t.status === 'pending')
    .reduce((sum, t) => sum + Math.abs(t.amount), 0);

  const totalBalance = users.reduce((sum, u) => sum + u.balance, 0);

  res.json({
    totalUsers: users.length,
    activeCampaigns: activeCampaigns.length,
    totalCampaigns: campaigns.length,
    pendingSubmissions: pendingSubmissions.length,
    submissionsToday: submissionsToday.length,
    flaggedSubmissions: flaggedSubmissions.length,
    approvedSubmissions: submissions.filter(s => s.status === 'approved').length,
    totalSubmissions: submissions.length,
    payoutToday,
    payoutWeek,
    totalPendingPayout,
    totalBalance,
    totalEarnings: transactions
      .filter(t => t.type === 'earning' && t.status === 'completed')
      .reduce((sum, t) => sum + t.amount, 0)
  });
});

// ==================== ADMIN USER MANAGEMENT ====================

// Get all users (Admin only)
app.get('/api/admin/users', verifyToken, requireRole(['admin']), (req, res) => {
  const userList = users.map(u => {
    const userSubmissions = submissions.filter(s => s.userId === u.id);
    const approved = userSubmissions.filter(s => s.status === 'approved').length;
    const approvalRate = userSubmissions.length > 0
      ? Math.round((approved / userSubmissions.length) * 100)
      : 0;

    return {
      id: u.id,
      email: u.email,
      name: u.name,
      role: u.role,
      status: u.status,
      balance: u.balance,
      pendingBalance: u.pendingBalance,
      totalSubmissions: userSubmissions.length,
      approvedSubmissions: approved,
      approvalRate,
      createdAt: u.createdAt
    };
  });

  res.json({ users: userList });
});

// Get single user details (Admin only)
app.get('/api/admin/users/:id', verifyToken, requireRole(['admin']), (req, res) => {
  const user = users.find(u => u.id === req.params.id);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  const userSubmissions = submissions.filter(s => s.userId === user.id);
  const userTransactions = transactions.filter(t => t.userId === user.id);

  res.json({
    ...user,
    submissions: userSubmissions,
    transactions: userTransactions
  });
});

// Update user status (Admin only) - suspend, blacklist, activate
app.patch('/api/admin/users/:id/status', verifyToken, requireRole(['admin']), (req, res) => {
  const { status } = req.body; // 'active', 'suspended', 'blacklisted'
  if (!['active', 'suspended', 'blacklisted'].includes(status)) {
    return res.status(400).json({ error: 'Invalid status' });
  }

  const user = users.find(u => u.id === req.params.id);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  const oldStatus = user.status;
  user.status = status;

  logAudit(req.userId, 'UPDATE_USER_STATUS', {
    userId: user.id,
    oldStatus,
    newStatus: status
  });

  res.json({ user });
});

// Update user role (Admin only)
app.patch('/api/admin/users/:id/role', verifyToken, requireRole(['admin']), (req, res) => {
  const { role } = req.body;
  if (!['admin', 'clipper', 'influencer'].includes(role)) {
    return res.status(400).json({ error: 'Invalid role' });
  }

  const user = users.find(u => u.id === req.params.id);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  const oldRole = user.role;
  user.role = role;

  logAudit(req.userId, 'UPDATE_USER_ROLE', {
    userId: user.id,
    oldRole,
    newRole: role
  });

  res.json({ user: { id: user.id, email: user.email, name: user.name, role: user.role } });
});

// Verify/Unverify influencer (Admin only)
app.patch('/api/admin/users/:id/verify', verifyToken, requireRole(['admin']), (req, res) => {
  const { verified } = req.body;

  const user = users.find(u => u.id === req.params.id);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  if (user.role !== 'influencer') {
    return res.status(400).json({ error: 'Only influencers can be verified' });
  }

  const oldVerified = user.verified || false;
  user.verified = verified === true;
  if (user.verified) {
    user.status = 'verified';
  } else {
    user.status = 'active';
  }

  logAudit(req.userId, verified ? 'VERIFY_INFLUENCER' : 'UNVERIFY_INFLUENCER', {
    userId: user.id,
    email: user.email
  });

  res.json({ user });
});

// Adjust user balance (Admin only)
app.patch('/api/admin/users/:id/balance', verifyToken, requireRole(['admin']), (req, res) => {
  const { amount, type, reason } = req.body; // type: 'add' or 'subtract'

  if (!amount || !type || !reason) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  const user = users.find(u => u.id === req.params.id);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  if (type === 'add') {
    user.balance += parseFloat(amount);
  } else if (type === 'subtract') {
    if (user.balance < amount) {
      return res.status(400).json({ error: 'Insufficient balance' });
    }
    user.balance -= parseFloat(amount);
  }

  logAudit(req.userId, 'ADJUST_USER_BALANCE', {
    userId: user.id,
    type,
    amount: parseFloat(amount),
    reason
  });

  res.json({ user });
});

// ==================== ADMIN WITHDRAW MANAGEMENT ====================

// Get all withdraw requests (Admin only)
app.get('/api/admin/withdraws', verifyToken, requireRole(['admin']), (req, res) => {
  const status = req.query.status; // Optional filter: PENDING, APPROVED, REJECTED

  let requests = withdrawRequests;
  if (status) {
    requests = requests.filter(w => w.status === status);
  }

  // Add user info
  const requestsWithUser = requests.map(request => {
    const user = users.find(u => u.id === request.userId);
    return {
      ...request,
      user: user ? {
        id: user.id,
        email: user.email,
        name: user.name,
        status: user.status
      } : null
    };
  });

  // Sort by created date (newest first)
  requestsWithUser.sort((a, b) =>
    new Date(b.createdAt) - new Date(a.createdAt)
  );

  res.json({ withdrawRequests: requestsWithUser });
});

// Get single withdraw request (Admin only)
app.get('/api/admin/withdraws/:id', verifyToken, requireRole(['admin']), (req, res) => {
  const request = withdrawRequests.find(w => w.id === req.params.id);
  if (!request) {
    return res.status(404).json({ error: 'Withdraw request not found' });
  }

  const user = users.find(u => u.id === request.userId);
  const userTransactions = transactions.filter(t => t.userId === request.userId);
  const userSubmissions = submissions.filter(s => s.userId === request.userId);

  res.json({
    ...request,
    user: user ? {
      id: user.id,
      email: user.email,
      name: user.name,
      status: user.status
    } : null,
    userStats: {
      totalTransactions: userTransactions.length,
      totalSubmissions: userSubmissions.length,
      approvedSubmissions: userSubmissions.filter(s => s.status === 'approved' || s.status === 'APPROVED').length
    }
  });
});

// Approve withdraw request (Admin only)
app.post('/api/admin/withdraws/:id/approve', verifyToken, requireRole(['admin']), (req, res) => {
  const request = withdrawRequests.find(w => w.id === req.params.id);
  if (!request) {
    return res.status(404).json({ error: 'Withdraw request not found' });
  }

  if (request.status !== 'PENDING') {
    return res.status(400).json({ error: `Cannot approve request with status: ${request.status}` });
  }

  const user = users.find(u => u.id === request.userId);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  // Update request
  request.status = 'APPROVED';
  request.reviewedAt = new Date().toISOString();
  request.reviewedBy = req.userId;

  // Create transaction: WITHDRAW_APPROVED
  const transaction = {
    id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    userId: request.userId,
    type: 'WITHDRAW_APPROVED',
    amount: -request.amount, // Negative
    description: `Withdrawal approved - ${request.paymentMethod?.label || 'Payment method'}`,
    status: 'completed',
    relatedEntityId: request.id,
    createdAt: new Date().toISOString(),
    date: new Date().toISOString()
  };

  transactions.push(transaction);

  logAudit(req.userId, 'APPROVE_WITHDRAW', {
    withdrawRequestId: request.id,
    userId: request.userId,
    amount: request.amount
  });

  res.json({ withdrawRequest: request, transaction });
});

// Reject withdraw request (Admin only)
app.post('/api/admin/withdraws/:id/reject', verifyToken, requireRole(['admin']), (req, res) => {
  const { reason } = req.body;

  if (!reason || reason.trim().length === 0) {
    return res.status(400).json({ error: 'Rejection reason is required' });
  }

  const request = withdrawRequests.find(w => w.id === req.params.id);
  if (!request) {
    return res.status(404).json({ error: 'Withdraw request not found' });
  }

  if (request.status !== 'PENDING') {
    return res.status(400).json({ error: `Cannot reject request with status: ${request.status}` });
  }

  const user = users.find(u => u.id === request.userId);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  // Update request
  request.status = 'REJECTED';
  request.reviewedAt = new Date().toISOString();
  request.reviewedBy = req.userId;
  request.rejectionReason = reason;

  // Create transaction: WITHDRAW_REJECTED (return funds)
  const transaction = {
    id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    userId: request.userId,
    type: 'WITHDRAW_REJECTED',
    amount: request.amount, // Positive (return funds)
    description: `Withdrawal rejected - ${reason}`,
    status: 'completed',
    relatedEntityId: request.id,
    createdAt: new Date().toISOString(),
    date: new Date().toISOString()
  };

  transactions.push(transaction);

  logAudit(req.userId, 'REJECT_WITHDRAW', {
    withdrawRequestId: request.id,
    userId: request.userId,
    amount: request.amount,
    reason
  });

  res.json({ withdrawRequest: request, transaction });
});

// Admin wallet adjustment
app.post('/api/admin/wallet/adjust', verifyToken, requireRole(['admin']), (req, res) => {
  const { userId, amount, type, reason } = req.body; // type: 'add' or 'subtract'

  if (!userId || !amount || !type || !reason) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  const user = users.find(u => u.id === userId);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  const adjustAmount = parseFloat(amount);
  const transactionAmount = type === 'add' ? adjustAmount : -adjustAmount;

  // Create transaction: ADMIN_ADJUSTMENT
  const transaction = {
    id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    userId,
    type: 'ADMIN_ADJUSTMENT',
    amount: transactionAmount,
    description: `Admin adjustment: ${reason}`,
    status: 'completed',
    createdAt: new Date().toISOString(),
    date: new Date().toISOString()
  };

  transactions.push(transaction);

  logAudit(req.userId, 'ADMIN_WALLET_ADJUSTMENT', {
    userId,
    type,
    amount: adjustAmount,
    reason
  });

  res.json({ transaction });
});

// ==================== ADMIN TRANSACTION MANAGEMENT ====================

// Update transaction status (Admin only) - mark payout as paid
app.patch('/api/admin/transactions/:id/status', verifyToken, requireRole(['admin']), (req, res) => {
  const { status } = req.body; // 'pending', 'completed', 'cancelled'

  const transaction = transactions.find(t => t.id === req.params.id);
  if (!transaction) {
    return res.status(404).json({ error: 'Transaction not found' });
  }

  const oldStatus = transaction.status;
  transaction.status = status;

  // If marking as completed, update user balance
  if (status === 'completed' && oldStatus === 'pending' && transaction.type === 'withdrawal') {
    // Balance already deducted on creation, so nothing to do
  }

  // If cancelling, refund balance
  if (status === 'cancelled' && oldStatus === 'pending' && transaction.type === 'withdrawal') {
    const user = users.find(u => u.id === transaction.userId);
    if (user) {
      user.balance += Math.abs(transaction.amount);
    }
  }

  logAudit(req.userId, 'UPDATE_TRANSACTION_STATUS', {
    transactionId: transaction.id,
    oldStatus,
    newStatus: status
  });

  res.json({ transaction });
});

// ==================== ADMIN INFLUENCER REVIEW ====================

// Get all influencer applications (Admin only)
app.get('/api/admin/influencers', verifyToken, requireRole(['admin']), (req, res) => {
  const status = req.query.status; // Optional filter: PENDING_REVIEW, VERIFIED, REJECTED

  let profiles = influencerProfiles;
  if (status) {
    profiles = profiles.filter(p => p.status === status);
  }

  // Add user info
  const profilesWithUser = profiles.map(profile => {
    const user = users.find(u => u.id === profile.userId);
    return {
      ...profile,
      user: user ? {
        id: user.id,
        email: user.email,
        name: user.name,
        createdAt: user.createdAt
      } : null
    };
  });

  // Sort by submitted date (newest first)
  profilesWithUser.sort((a, b) =>
    new Date(b.submittedAt) - new Date(a.submittedAt)
  );

  res.json({ influencers: profilesWithUser });
});

// Get single influencer application (Admin only)
app.get('/api/admin/influencers/:id', verifyToken, requireRole(['admin']), (req, res) => {
  const profile = influencerProfiles.find(p => p.id === req.params.id);
  if (!profile) {
    return res.status(404).json({ error: 'Influencer application not found' });
  }

  const user = users.find(u => u.id === profile.userId);
  res.json({
    ...profile,
    user: user ? {
      id: user.id,
      email: user.email,
      name: user.name,
      createdAt: user.createdAt
    } : null
  });
});

// Approve influencer application (Admin only)
app.post('/api/admin/influencers/:id/approve', verifyToken, requireRole(['admin']), (req, res) => {
  const profile = influencerProfiles.find(p => p.id === req.params.id);
  if (!profile) {
    return res.status(404).json({ error: 'Influencer application not found' });
  }

  if (profile.status === 'VERIFIED') {
    return res.status(400).json({ error: 'Application already approved' });
  }

  const user = users.find(u => u.id === profile.userId);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  // Update profile
  profile.status = 'VERIFIED';
  profile.reviewedAt = new Date().toISOString();
  profile.reviewedBy = req.userId;

  // Update user
  user.influencerStatus = 'VERIFIED';
  user.verified = true;
  // User can now activate influencer role if they want

  logAudit(req.userId, 'APPROVE_INFLUENCER', {
    influencerId: profile.id,
    userId: profile.userId,
    influencerName: profile.influencerName
  });

  res.json({ profile, user });
});

// Reject influencer application (Admin only)
app.post('/api/admin/influencers/:id/reject', verifyToken, requireRole(['admin']), (req, res) => {
  const { reason } = req.body;

  if (!reason || reason.trim().length === 0) {
    return res.status(400).json({ error: 'Rejection reason is required' });
  }

  const profile = influencerProfiles.find(p => p.id === req.params.id);
  if (!profile) {
    return res.status(404).json({ error: 'Influencer application not found' });
  }

  if (profile.status === 'VERIFIED') {
    return res.status(400).json({ error: 'Cannot reject an approved application' });
  }

  const user = users.find(u => u.id === profile.userId);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  // Update profile
  profile.status = 'REJECTED';
  profile.reviewedAt = new Date().toISOString();
  profile.reviewedBy = req.userId;
  profile.rejectionReason = reason;

  // Update user
  user.influencerStatus = 'REJECTED';
  user.verified = false;

  logAudit(req.userId, 'REJECT_INFLUENCER', {
    influencerId: profile.id,
    userId: profile.userId,
    influencerName: profile.influencerName,
    reason
  });

  res.json({ profile, user });
});

// ==================== ADMIN AUDIT LOG ====================

// Get audit logs (Admin only)
app.get('/api/admin/audit-logs', verifyToken, requireRole(['admin']), (req, res) => {
  const limit = parseInt(req.query.limit) || 100;
  const logs = auditLogs
    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
    .slice(0, limit)
    .map(log => {
      const admin = users.find(u => u.id === log.adminId);
      return {
        ...log,
        adminName: admin?.name || 'Unknown'
      };
    });

  res.json({ logs });
});

// ==================== INFLUENCER ENDPOINTS ====================

// Get influencer dashboard stats
app.get('/api/influencer/stats', verifyToken, requireRole(['influencer']), (req, res) => {
  const influencerCampaigns = campaigns.filter(c => c.createdBy === req.userId);
  const activeCampaigns = influencerCampaigns.filter(c => c.status === 'ACTIVE');

  const influencerSubmissions = submissions.filter(s =>
    influencerCampaigns.some(c => c.id === s.campaignId)
  );

  const totalViews = influencerSubmissions
    .filter(s => s.status === 'approved')
    .reduce((sum, s) => sum + s.views, 0);

  const totalBudget = influencerCampaigns.reduce((sum, c) => sum + (c.totalBudget || c.budget || 0), 0);
  const spentBudget = influencerCampaigns.reduce((sum, c) => sum + (c.paidBudget || c.spentBudget || 0), 0);

  const user = users.find(u => u.id === req.userId);
  const estimatedROI = totalViews > 0 && spentBudget > 0
    ? ((totalViews / 1000) * (influencerCampaigns[0]?.rate || 0) - spentBudget) / spentBudget * 100
    : 0;

  res.json({
    activeCampaigns: activeCampaigns.length,
    totalCampaigns: influencerCampaigns.length,
    totalViews,
    totalBudget,
    spentBudget,
    remainingBudget: user.budget || 0,
    estimatedROI: estimatedROI.toFixed(2),
    totalClips: influencerSubmissions.filter(s => s.status === 'approved').length
  });
});

// Get influencer campaigns
app.get('/api/influencer/campaigns', verifyToken, requireRole(['influencer']), (req, res) => {
  const influencerCampaigns = campaigns.filter(c => c.createdBy === req.userId);
  res.json({ campaigns: influencerCampaigns });
});

// Get influencer submissions (no clipper info)
app.get('/api/influencer/submissions', verifyToken, requireRole(['influencer']), (req, res) => {
  const influencerCampaigns = campaigns.filter(c => c.createdBy === req.userId);
  const influencerCampaignIds = influencerCampaigns.map(c => c.id);

  const influencerSubmissions = submissions
    .filter(s => influencerCampaignIds.includes(s.campaignId))
    .map(s => {
      const { userId, ...submissionWithoutUserId } = s;
      return submissionWithoutUserId;
    });

  res.json({ submissions: influencerSubmissions });
});

// Top up budget (Influencer only)
app.post('/api/influencer/topup', verifyToken, requireRole(['influencer']), (req, res) => {
  const { amount } = req.body;

  if (!amount || amount <= 0) {
    return res.status(400).json({ error: 'Invalid amount' });
  }

  const user = users.find(u => u.id === req.userId);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  user.budget = (user.budget || 0) + parseFloat(amount);

  // Create transaction record
  const transaction = {
    id: `topup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    userId: req.userId,
    type: 'topup',
    amount: parseFloat(amount),
    description: 'Budget Top Up',
    status: 'completed',
    date: new Date().toISOString()
  };

  transactions.push(transaction);

  res.json({
    budget: user.budget,
    transaction
  });
});

// Get top up history (Influencer only)
app.get('/api/influencer/topup-history', verifyToken, requireRole(['influencer']), (req, res) => {
  const topupTransactions = transactions
    .filter(t => t.userId === req.userId && t.type === 'topup')
    .sort((a, b) => new Date(b.date) - new Date(a.date));

  res.json({ transactions: topupTransactions });
});

// ==================== INFLUENCER ONBOARDING ====================

// Apply to become influencer
app.post('/api/influencer/apply', verifyToken, (req, res) => {
  const {
    influencerName,
    influencerType,
    platformsOwned,
    primaryPlatform,
    channelUrl,
    followerCount,
    reasonForCampaigns,
    estimatedBudget,
    contactPersonName,
    preferredContactMethod,
    contactDetail,
    analyticsScreenshot,
    mediaKitUrl
  } = req.body;

  // Validation
  if (!influencerName || !channelUrl || !reasonForCampaigns || !contactPersonName || !contactDetail) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  if (!platformsOwned || !Array.isArray(platformsOwned) || platformsOwned.length === 0) {
    return res.status(400).json({ error: 'At least one platform must be selected' });
  }

  if (!primaryPlatform) {
    return res.status(400).json({ error: 'Primary platform is required' });
  }

  const user = users.find(u => u.id === req.userId);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  // Check if user already has a pending or verified application
  const existingProfile = influencerProfiles.find(p => p.userId === req.userId);
  if (existingProfile) {
    if (existingProfile.status === 'PENDING_REVIEW') {
      return res.status(400).json({ error: 'You already have a pending application' });
    }
    if (existingProfile.status === 'VERIFIED') {
      return res.status(400).json({ error: 'You are already a verified influencer' });
    }
    // If rejected, allow reapplication
  }

  const profile = {
    id: `influencer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    userId: req.userId,
    influencerName,
    influencerType: influencerType || 'PERSONAL',
    platformsOwned,
    primaryPlatform,
    channelUrl,
    followerCount: followerCount ? parseInt(followerCount) : null,
    reasonForCampaigns,
    estimatedBudget: estimatedBudget || null,
    contactPersonName,
    preferredContactMethod: preferredContactMethod || 'EMAIL',
    contactDetail,
    analyticsScreenshot: analyticsScreenshot || null,
    mediaKitUrl: mediaKitUrl || null,
    status: 'PENDING_REVIEW',
    submittedAt: new Date().toISOString(),
    reviewedAt: null,
    reviewedBy: null,
    rejectionReason: null,
    createdAt: new Date().toISOString()
  };

  // Update or create profile
  if (existingProfile) {
    const index = influencerProfiles.findIndex(p => p.userId === req.userId);
    influencerProfiles[index] = { ...existingProfile, ...profile, id: existingProfile.id };
  } else {
    influencerProfiles.push(profile);
  }

  // Update user influencer status
  user.influencerStatus = 'PENDING_REVIEW';
  // Don't set role yet - wait for approval

  res.status(201).json({ profile });
});

// Get influencer application status
app.get('/api/influencer/status', verifyToken, (req, res) => {
  const profile = influencerProfiles.find(p => p.userId === req.userId);
  const user = users.find(u => u.id === req.userId);

  if (!profile) {
    return res.status(404).json({ error: 'No influencer application found' });
  }

  res.json({
    status: profile.status,
    submittedAt: profile.submittedAt,
    reviewedAt: profile.reviewedAt,
    rejectionReason: profile.rejectionReason,
    profile: {
      influencerName: profile.influencerName,
      influencerType: profile.influencerType,
      primaryPlatform: profile.primaryPlatform,
      channelUrl: profile.channelUrl
    }
  });
});

// Set user role (for clipper selection)
app.post('/api/auth/set-role', verifyToken, (req, res) => {
  const { role } = req.body;

  if (!['clipper', 'influencer'].includes(role)) {
    return res.status(400).json({ error: 'Invalid role' });
  }

  const user = users.find(u => u.id === req.userId);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  // If setting to influencer, check if verified
  if (role === 'influencer') {
    const profile = influencerProfiles.find(p => p.userId === req.userId);
    if (!profile || profile.status !== 'VERIFIED') {
      return res.status(403).json({ error: 'You must be a verified influencer to use this role' });
    }
    user.verified = true;
  }

  user.role = role;
  res.json({ user: { id: user.id, email: user.email, name: user.name, role: user.role } });
});

// Get campaign performance report (Influencer only)
app.get('/api/influencer/campaigns/:id/report', verifyToken, requireRole(['influencer']), (req, res) => {
  const campaign = campaigns.find(c => c.id === req.params.id);
  if (!campaign) {
    return res.status(404).json({ error: 'Campaign not found' });
  }

  if (campaign.createdBy !== req.userId) {
    return res.status(403).json({ error: 'Forbidden' });
  }

  const campaignSubmissions = submissions.filter(s => s.campaignId === campaign.id);
  const approvedSubmissions = campaignSubmissions.filter(s => s.status === 'approved');

  const performance = {
    campaign: {
      ...campaign,
      // Remove sensitive info
      createdBy: undefined
    },
    totalClips: approvedSubmissions.length,
    totalViews: approvedSubmissions.reduce((sum, s) => sum + s.views, 0),
    totalLikes: approvedSubmissions.reduce((sum, s) => sum + s.likes, 0),
    budgetUsed: campaign.spentBudget,
    budgetRemaining: campaign.budget - campaign.spentBudget,
    clips: approvedSubmissions.map(s => ({
      id: s.id,
      title: s.title,
      thumbnail: s.thumbnail,
      videoUrl: s.videoUrl,
      views: s.views,
      likes: s.likes,
      platform: campaign.platform,
      submittedAt: s.submittedAt
      // NO clipper info
    }))
  };

  res.json({ report: performance });
});

// Initialize with a default admin user
if (users.length === 0) {
  const adminUser = {
    id: 'admin_1',
    email: 'admin@clipflow.com',
    password: 'admin123', // Change this in production!
    name: 'Admin User',
    role: 'admin',
    balance: 0,
    pendingBalance: 0,
    budget: 0,
    status: 'active',
    createdAt: new Date().toISOString()
  };
  users.push(adminUser);

  // Add a default influencer for testing (verified)
  const influencerUser = {
    id: 'influencer_1',
    email: 'influencer@clipflow.com',
    password: 'influencer123',
    name: 'Influencer User',
    role: 'influencer',
    balance: 0,
    pendingBalance: 0,
    budget: 10000, // Starting budget
    status: 'verified',
    verified: true,
    createdAt: new Date().toISOString()
  };
  users.push(influencerUser);
}

// Start server
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
